# 2022 August 28
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
#

if {![info exists testdir]} {
  set testdir [file join [file dirname [info script]] .. .. test]
} 
source [file join [file dirname [info script]] recover_common.tcl]
source $testdir/tester.tcl

set testprefix recover1



proc compare_result {db1 db2 sql} {
  set r1 [$db1 eval $sql]
  set r2 [$db2 eval $sql]
  if {$r1 != $r2} {
    puts "r1: $r1"
    puts "r2: $r2"
    error "mismatch for $sql"
  }
  return ""
}

proc compare_dbs {db1 db2} {
  compare_result $db1 $db2 "SELECT sql FROM sqlite_master ORDER BY 1"
  foreach tbl [$db1 eval {SELECT name FROM sqlite_master WHERE type='table'}] {
    compare_result $db1 $db2 "SELECT * FROM $tbl"
  }
}

proc do_recover_test {tn} {
  forcedelete test.db2
  forcedelete rstate.db

  uplevel [list do_test $tn.1 {
    set R [sqlite3_recover_init db main test.db2]
    $R config testdb rstate.db
    $R step
    $R finish
  } {}]

  sqlite3 db2 test.db2
  uplevel [list do_test $tn.2 [list compare_dbs db db2] {}]
  db2 close

  forcedelete test.db2
  forcedelete rstate.db

  uplevel [list do_test $tn.3 {
    set ::sqlhook [list]
    set R [sqlite3_recover_init_sql db main my_sql_hook]
    $R config testdb rstate.db
    $R config rowids 1
    $R step
    $R finish
  } {}]

  sqlite3 db2 test.db2
  execsql [join $::sqlhook ";"] db2
  uplevel [list do_test $tn.4 [list compare_dbs db db2] {}]
  db2 close
}

proc my_sql_hook {sql} {
  lappend ::sqlhook $sql
}

do_execsql_test 1.0 {
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b);
  CREATE TABLE t2(a INTEGER PRIMARY KEY, b) WITHOUT ROWID;
  WITH s(i) AS (
    SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<10
  )
  INSERT INTO t1 SELECT i*2, hex(randomblob(250)) FROM s;
  INSERT INTO t2 SELECT * FROM t1;

}

do_recover_test 1

do_execsql_test 2.0 {
  ALTER TABLE t1 ADD COLUMN c DEFAULT 'xyz'
}
do_recover_test 2

do_execsql_test 3.0 {
  CREATE INDEX i1 ON t1(c);
}
do_recover_test 3

do_execsql_test 4.0 {
  CREATE VIEW v1 AS SELECT * FROM t2;
}
do_recover_test 4

do_execsql_test 5.0 {
  CREATE UNIQUE INDEX i2 ON t1(c, b);
}
do_recover_test 5

#--------------------------------------------------------------------------
#
reset_db
do_execsql_test 6.0 {
  CREATE TABLE t1(
      a INTEGER PRIMARY KEY,
      b INT,
      c TEXT,
      d INT GENERATED ALWAYS AS (a*abs(b)) VIRTUAL,
      e TEXT GENERATED ALWAYS AS (substr(c,b,b+1)) STORED,
      f TEXT GENERATED ALWAYS AS (substr(c,b,b+1)) STORED
  );

  INSERT INTO t1 VALUES(1, 2, 'hello world');
}
do_recover_test 6

do_execsql_test 7.0 {
  CREATE TABLE t2(i, j GENERATED ALWAYS AS (i+1) STORED, k);
  INSERT INTO t2 VALUES(10, 'ten');
}
do_execsql_test 7.1 {
  SELECT * FROM t2
} {10 11 ten}

do_recover_test 7.2

#--------------------------------------------------------------------------
#
reset_db
do_execsql_test 8.0 {
  CREATE TABLE x1(a INTEGER PRIMARY KEY AUTOINCREMENT, b, c);
  WITH s(i) AS (
    SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<2
  )
  INSERT INTO x1(b, c) SELECT hex(randomblob(100)), hex(randomblob(100)) FROM s;
  
  CREATE INDEX x1b ON x1(b);
  CREATE INDEX x1cb ON x1(c, b);
  DELETE FROM x1 WHERE a>50;

  ANALYZE;
}

do_recover_test 8



finish_test

