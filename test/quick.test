# 2001 September 15
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file runs all tests.
#
# $Id: quick.test,v 1.8 2004/05/13 11:34:17 danielk1977 Exp $

set testdir [file dirname $argv0]
source $testdir/tester.tcl
rename finish_test really_finish_test
proc finish_test {} {}
set ISQUICK 1

set EXCLUDE {
  all.test
  quick.test
  btree2.test
  malloc.test
  memleak.test
  misuse.test
  format3.test
}

lappend EXCLUDE interrupt.test    ;# seg-faults (?)
lappend EXCLUDE intpkey.test      ;# seg-faults (?)
lappend EXCLUDE ioerr.test        ;# seg-faults (?)
lappend EXCLUDE memdb.test        ;# fails - malformed database
lappend EXCLUDE misc3.test        ;# seg-faults (?)
lappend EXCLUDE printf.test       ;# sqlite3_XX vs sqlite_XX problem
lappend EXCLUDE rowid.test        ;# sql logic error
lappend EXCLUDE table.test        ;# assert() fails in pager
lappend EXCLUDE trans.test        ;# assert() fails in btree
lappend EXCLUDE vacuum.test       ;# assert() fails in btree

lappend EXCLUDE auth.test         ;# Cannot attach empty databases.
lappend EXCLUDE tableapi.test     ;# sqlite3_XX vs sqlite_XX problem
lappend EXCLUDE version.test      ;# uses the btree_meta API (not updated)

# Some tests fail in these file, possibly because of the manifest
# type-aware indices.
lappend EXCLUDE delete.test
lappend EXCLUDE update.test 
lappend EXCLUDE misc1.test 
lappend EXCLUDE index.test 
lappend EXCLUDE copy.test 
lappend EXCLUDE conflict.test 
lappend EXCLUDE capi2.test 
lappend EXCLUDE null.test 
lappend EXCLUDE trigger2.test 
lappend EXCLUDE where.test
lappend EXCLUDE unique.test 
lappend EXCLUDE limit.test


if {[sqlite -has-codec]} {
  lappend EXCLUDE \
    attach.test \
    attach2.test \
    auth.test \
    format3.test \
    version.test
}

foreach testfile [lsort -dictionary [glob $testdir/*.test]] {
  set tail [file tail $testfile]
  if {[lsearch -exact $EXCLUDE $tail]>=0} continue
  source $testfile
  catch {db close}
  if {$sqlite_open_file_count>0} {
    puts "$tail did not close all files: $sqlite_open_file_count"
    incr nErr
    lappend ::failList $tail
  }
}
# source $testdir/misuse.test

set sqlite_open_file_count 0
really_finish_test
