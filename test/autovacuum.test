# 2001 September 15
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for SQLite library.  The
# focus of this file is testing the SELECT statement.
#
# $Id: autovacuum.test,v 1.8 2004/11/05 12:58:26 danielk1977 Exp $

set testdir [file dirname $argv0]
source $testdir/tester.tcl

# Return a string $len characters long. The returned string is $char repeated
# over and over. For example, [make_str abc 8] returns "abcabcab".
proc make_str {char len} {
  set str [string repeat $char. $len]
  return [string range $str 0 [expr $len-1]]
}

# Return the number of pages in the file test.db by looking at the file system.
proc file_pages {} {
  return [expr [file size test.db] / 1024]
}

# Test cases autovacuum-1.* work as follows:
#
# 1. A table with a single indexed field is created.
# 2. Approximately 20 rows are inserted into the table. Each row is long 
#    enough such that it uses at least 2 overflow pages for both the table 
#    and index entry.
# 3. The rows are deleted in a psuedo-random order. Sometimes only one row
#    is deleted per transaction, sometimes more than one.
# 4. After each transaction the table data is checked to ensure it is correct
#    and a "PRAGMA integrity_check" is executed.
# 5. Once all the rows are deleted the file is checked to make sure it 
#    consists of exactly 4 pages.
#
# Steps 2-5 are repeated for a few different psuedo-random delete patterns 
# (defined by the $delete_orders list).
set delete_orders [list]
lappend delete_orders {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20}
lappend delete_orders {20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1} 
lappend delete_orders {8 18 2 4 14 11 13 3 10 7 9 5 12 17 19 15 20 6 16 1}
lappend delete_orders {10 3 11 17 19 20 7 4 13 6 1 14 16 12 9 18 8 15 5 2}
lappend delete_orders {{1 2 3 4 5 6 7 8 9 10} {11 12 13 14 15 16 17 18 19 20}}
lappend delete_orders {{19 8 17 15} {16 11 9 14} {18 5 3 1} {13 20 7 2} {6 12}}

# The length of each table entry. 
set ENTRY_LEN 3500

do_test autovacuum-1.1 {
  execsql {
    CREATE TABLE av1(a);
    CREATE INDEX av1_idx ON av1(a);
  }
} {}

set tn 0
foreach delete_order $delete_orders {
  incr tn

  # Set up the table.
  set ::tbl_data [list]
  foreach i [lsort -integer [eval concat $delete_order]] {
    execsql "INSERT INTO av1 (oid, a) VALUES($i, '[make_str $i $ENTRY_LEN]')"
    lappend ::tbl_data [make_str $i $ENTRY_LEN]
  }

  # Make sure the integrity check passes with the initial data.
  do_test autovacuum-1.$tn.1 {
    execsql {
      pragma integrity_check
    }
  } {ok}

# set btree_trace 1
  foreach delete $delete_order {
    # Delete one set of rows from the table.
    do_test autovacuum-1.$tn.($delete).1 {
      execsql "
        DELETE FROM av1 WHERE oid IN ([join $delete ,])
      "
    } {}

    # Do the integrity check.
    do_test autovacuum-1.$tn.($delete).2 {
      execsql {
        pragma integrity_check
      }
    } {ok}

    # Ensure the data remaining in the table is what was expected.
    foreach d $delete {
      set idx [lsearch $::tbl_data [make_str $d $ENTRY_LEN]]
      set ::tbl_data [lreplace $::tbl_data $idx $idx]
    }
    do_test autovacuum-1.$tn.($delete).3 {
      execsql {
        select a from av1
      }
    } $::tbl_data
  }

  # All rows have been deleted. Ensure the file has shrunk to 4 pages.
  do_test autovacuum-1.$tn.3 {
    file_pages
  } {4}
}

# Tests cases autovacuum-2.* test that root pages are allocated 
# and deallocated correctly at the start of the file. Operation is roughly as
# follows:
#
# autovacuum-2.1.*: Drop the tables that currently exist in the database.
# autovacuum-2.2.*: Create some tables. Ensure that data pages can be
#                   moved correctly to make space for new root-pages.
# autovacuum-2.3.*: Drop one of the tables just created (not the last one),
#                   and check that one of the other tables is moved to
#                   the free root-page location.
# autovacuum-2.4.*: Check that a table can be created correctly when the
#                   root-page it requires is on the free-list.
#
do_test autovacuum-2.1.1 {
  execsql {
    DROP TABLE av1;
  }
} {}
do_test autovacuum-2.1.2 {
  file_pages
} {1}

# Create a table and put some data in it.
do_test autovacuum-2.2.1 {
  execsql {
    CREATE TABLE av1(x);
    SELECT rootpage FROM sqlite_master ORDER BY rootpage;
  }
} {3}
do_test autovacuum-2.2.2 {
  execsql "
    INSERT INTO av1 VALUES('[make_str abc 3000]');
    INSERT INTO av1 VALUES('[make_str def 3000]');
    INSERT INTO av1 VALUES('[make_str ghi 3000]');
    INSERT INTO av1 VALUES('[make_str jkl 3000]');
  "
  set ::av1_data [db eval {select * from av1}]
  file_pages
} {15}

# Create another table. Check it is located immediately after the first.
# This test case moves the second page in an over-flow chain.
do_test autovacuum-2.2.3 {
  execsql {
    CREATE TABLE av2(x);
    SELECT rootpage FROM sqlite_master ORDER BY rootpage;
  }
} {3 4}
do_test autovacuum-2.2.4 {
  file_pages
} {16}

# Create another table. Check it is located immediately after the second.
# This test case moves the first page in an over-flow chain.
do_test autovacuum-2.2.5 {
  execsql {
    CREATE TABLE av3(x);
    SELECT rootpage FROM sqlite_master ORDER BY rootpage;
  }
} {3 4 5}
do_test autovacuum-2.2.6 {
  file_pages
} {17}

# Create another table. Check it is located immediately after the second.
# This test case moves a btree leaf page.
do_test autovacuum-2.2.7 {
  execsql {
    CREATE TABLE av4(x);
    SELECT rootpage FROM sqlite_master ORDER BY rootpage;
  }
} {3 4 5 6}
do_test autovacuum-2.2.8 {
  file_pages
} {18}
do_test autovacuum-2.2.9 {
  execsql {
    select * from av1
  }
} $av1_data

do_test autovacuum-2.3.1 {
  execsql {
    INSERT INTO av2 SELECT 'av1' || x FROM av1;
    INSERT INTO av3 SELECT 'av2' || x FROM av1;
    INSERT INTO av4 SELECT 'av3' || x FROM av1;
  }
  set ::av2_data [execsql {select x from av2}]
  set ::av3_data [execsql {select x from av3}]
  set ::av4_data [execsql {select x from av4}]
  file_pages
} {54}
do_test autovacuum-2.3.2 {
  execsql {
    DROP TABLE av2;
    SELECT rootpage FROM sqlite_master ORDER BY rootpage;
  }
} {3 4 5}
do_test autovacuum-2.3.3 {
  file_pages
} {41}
do_test autovacuum-2.3.4 {
  execsql {
    SELECT x FROM av3;
  }
} $::av3_data
do_test autovacuum-2.3.5 {
  execsql {
    SELECT x FROM av4;
  }
} $::av4_data

# Drop all the tables in the file. This puts all pages except the first 2
# (the sqlite_master root-page and the first pointer map page) on the 
# free-list.
do_test autovacuum-2.4.1 {
  execsql {
    DROP TABLE av1;
    DROP TABLE av3;
    BEGIN;
    DROP TABLE av4;
  }
  file_pages
} {15}
do_test autovacuum-2.4.2 {
  for {set i 3} {$i<=10} {incr i} {
    execsql "CREATE TABLE av$i (x)"
  }
  file_pages
} {15}
do_test autovacuum-2.4.3 {
  execsql {
    SELECT rootpage FROM sqlite_master ORDER by rootpage
  }
} {3 4 5 6 7 8 9 10}

# Right now there are 5 free pages in the database. Consume and then free
# a 520 pages. Then create 520 tables. This ensures that at least some of the
# desired root-pages reside on the second free-list trunk page, and that the
# trunk itself is required at some point.
do_test autovacuum-2.4.4 {
  execsql "
    INSERT INTO av3 VALUES ('[make_str abcde [expr 1020*520 + 500]]');
    DELETE FROM av3;
  "
} {}
set root_page_list [list]
for {set i 3} {$i<=532} {incr i} {
  # 207 and 412 are pointer-map pages.
  if { $i!=207 && $i!=412 } {
    lappend root_page_list $i
  }
}
do_test autovacuum-2.4.5 {
  for {set i 11} {$i<=530} {incr i} {
    execsql "CREATE TABLE av$i (x)"
  }
  execsql {
    SELECT rootpage FROM sqlite_master ORDER by rootpage
  }
} $root_page_list

# Just for fun, delete all those tables and see if the database is 1 page.
do_test autovacuum-2.4.6 {
  execsql COMMIT;
  file_pages
} 561
integrity_check autovacuum-2.4.6
do_test autovacuum-2.4.7 {
  execsql BEGIN
  for {set i 3} {$i<=530} {incr i} {
    execsql "DROP TABLE av$i"
  }
  execsql COMMIT
  file_pages
} 1

finish_test

