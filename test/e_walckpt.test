# 2014 December 04
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
source $testdir/lock_common.tcl
source $testdir/wal_common.tcl
set testprefix e_walckpt

# The following two commands are used to determine if any of the files
# "test.db", "test.db2" and "test.db3" are modified by a test case.
#
# The [save_db_hashes] command saves a hash of the current contents of
# all three files in global variables. The [compare_db_hashes] compares
# the current contents with the saved hashes and returns a list of the
# files that have changed.
#
proc save_db_hashes {} {
  global H
  foreach f {test.db test.db2 test.db3} {
    set H($f) 0
    catch { set H($f) [md5file $f] }
  }
}
proc compare_db_hashes {} {
  global H
  set ret [list]
  foreach f {test.db test.db2 test.db3} {
    set expect 0
    catch { set expect [md5file $f] }
    if {$H($f) != $expect} { lappend ret $f }
  }
  set ret
}


# The following tests are run 3 times, each using a different method of 
# invoking a checkpoint:
#
#   1) Using sqlite3_wal_checkpoint_v2()
#   2) Using "PRAGMA wal_checkpoint"
#   3) Using sqlite3_wal_checkpoint() in place of checkpoint_v2(PASSIVE)
#
# Cases (2) and (3) are to show that the following statements are 
# correct, respectively:
#
# EVIDENCE-OF: R-36706-10507 The PRAGMA wal_checkpoint command can be
# used to invoke this interface from SQL.
#
# EVIDENCE-OF: R-41613-20553 The sqlite3_wal_checkpoint(D,X) is
# equivalent to
# sqlite3_wal_checkpoint_v2(D,X,SQLITE_CHECKPOINT_PASSIVE,0,0).
# 
foreach {tn script} {
  1 {
    proc checkpoint {db mode args} {
      eval sqlite3_wal_checkpoint_v2 [list $db] [list $mode] $args
    }
  }

  2 {
    proc checkpoint {db mode args} {
      set sql "PRAGMA wal_checkpoint = $mode"
      if {[llength $args] && [lindex $args 0]!=""} {
        set sql "PRAGMA [lindex $args 0].wal_checkpoint = $mode"
      }
      set rc [catch { $db eval $sql } msg]
      if {$rc} {
        regsub {database} $msg {database:} msg
        error "[sqlite3_errcode $db] - $msg"
      }
      set msg
    }
  }

  3 {
    proc checkpoint {db mode args} {
      if {$mode == "passive"} {
        set rc [eval sqlite3_wal_checkpoint [list $db] $args]
        if {$rc != "SQLITE_OK"} {
          error "$rc - [sqlite3_errmsg $db]"
        }
      } else {
        eval sqlite3_wal_checkpoint_v2 [list $db] [list $mode] $args
      }
    }
  }

} {

  eval $script

  reset_db
  forcedelete test.db2 test.db3 test.db4
  execsql {
    ATTACH 'test.db2' AS aux;
    ATTACH 'test.db3' AS aux2;
    ATTACH 'test.db4' AS aux3;
    CREATE TABLE t1(x);
    CREATE TABLE aux.t2(x);
    CREATE TABLE aux2.t3(x);
    CREATE TABLE aux3.t4(x);
    PRAGMA main.journal_mode = WAL;
    PRAGMA aux.journal_mode = WAL;
    PRAGMA aux2.journal_mode = WAL;
    /* Leave aux4 in rollback mode */
  }

  # EVIDENCE-OF: R-49787-09095 The sqlite3_wal_checkpoint_v2(D,X,M,L,C)
  # interface runs a checkpoint operation on database X of database
  # connection D in mode M. Status information is written back into
  # integers pointed to by L and C.
  #
  #     Tests 1, 2 and 3 below verify the "on database X" part of the
  #     above. Other parts of this requirement are tested below.
  #
  # EVIDENCE-OF: R-00653-06026 If parameter zDb is NULL or points to a
  # zero length string, then the specified operation is attempted on all
  # WAL databases attached to database connection db.
  #
  #     Tests 4 and 5 below test this.
  #
  foreach {tn2 zDb dblist} {
    1 main  test.db
    2 aux   test.db2
    3 aux2  test.db3
    4 ""    {test.db test.db2 test.db3}
    5 -     {test.db test.db2 test.db3}
    6 temp  {}
  } {
    do_test $tn.1.$tn2 {
      execsql {
        INSERT INTO t1 VALUES(1);
        INSERT INTO t2 VALUES(2);
        INSERT INTO t3 VALUES(3);
      }
      save_db_hashes

      if {$zDb == "-"} {
        checkpoint db passive
      } else {
        checkpoint db passive $zDb
      }

      compare_db_hashes
    } $dblist
  }

  # EVIDENCE-OF: R-38207-48996 If zDb is not NULL (or a zero length
  # string) and is not the name of any attached database, SQLITE_ERROR is
  # returned to the caller.
  do_test $tn.2.1 {
    list [catch { checkpoint db passive notadb } msg] $msg
  } {1 {SQLITE_ERROR - unknown database: notadb}}

  # EVIDENCE-OF: R-14303-42483 If database zDb is the name of an attached
  # database that is not in WAL mode, SQLITE_OK is returned and both
  # *pnLog and *pnCkpt set to -1.
  #
  if {$tn==3} {
    # With sqlite3_wal_checkpoint() the two output variables cannot be 
    # tested. So just test that no error is returned when attempting to
    # checkpoint a db in rollback mode.
    do_test $tn.2.2.a { checkpoint db passive aux3 } {}
  } else {
    do_test $tn.2.2.b { checkpoint db passive aux3 } {0 -1 -1}
  }

  # EVIDENCE-OF: R-62028-47212 All calls obtain an exclusive "checkpoint"
  # lock on the database file.
  db close
  testvfs tvfs
  tvfs filter xShmLock
  tvfs script filelock
  proc filelock {method file handle details} {
    # Test for an exclusive checkpoint lock. A checkpoint lock locks a
    # single byte starting at offset 1.
    if {$details == "1 1 lock exclusive"} { set ::seen_checkpoint_lock 1 }
  }
  sqlite3 db test.db -vfs tvfs
  do_test $tn.3.1 {
    execsql { INSERT INTO t1 VALUES('xyz') }
    unset -nocomplain ::seen_checkpoint_lock
    checkpoint db passive
    set ::seen_checkpoint_lock
  } {1}
  db close
  tvfs delete
  reset_db


 

  #-----------------------------------------------------------------------
  # EVIDENCE-OF: R-10421-19736 If any other process is running a
  # checkpoint operation at the same time, the lock cannot be obtained and
  # SQLITE_BUSY is returned.
  #
  # EVIDENCE-OF: R-53820-33897 Even if there is a busy-handler configured,
  # it will not be invoked in this case.
  #
  testvfs tvfs
  tvfs filter xWrite
  sqlite3 db test.db -vfs tvfs
  sqlite3 db2 test.db -vfs tvfs

  do_test $tn.3.2.1 {
    db2 eval {
      PRAGMA journal_mode = WAL;
      CREATE TABLE t1(x, y);
      INSERT INTO t1 VALUES(1,2);
      INSERT INTO t1 VALUES(3,4);
      INSERT INTO t1 VALUES(5,6);
    }
    file size test.db-wal
  } [wal_file_size 5 1024]


  # Connection [db] runs a checkpoint. During this checkpoint, each
  # time it calls xWrite() to write a page into the database file, we
  # attempt to start a checkpoint using [db2]. According to the 
  # first requirement being tested, this should return SQLITE_BUSY. According
  # to the second, the busy-handler belonging to [db2] should not be
  # invoked.
  #
  set ::write_count 0
  set ::write_errors [list]
  proc busy_callback {args} {
    lappend ::write_errors "busy handler called!"
  }
  proc write_callback {args} {
    set rc [catch {checkpoint db2 passive} msg]
    if {0==[regexp "database is locked" $msg] && $msg!="1 -1 -1"} {
      lappend ::write_errors "$rc $msg"
    } 
    incr ::write_count
  }
  db2 busy busy_callback
  tvfs script write_callback

  do_test $tn.3.2.2 {
    db eval {SELECT * FROM sqlite_master}
    checkpoint db full
    set ::write_count
  } {2}

  do_test $tn.3.2.3 {
    set ::write_errors
  } {}

  db close
  db2 close
  tvfs delete

  proc busy_handler {mode busy_handler_mode n} {
    incr ::busy_handler_counter
    switch -- $busy_handler_mode {
      1 {
        # Do nothing. Do not block.
        return 1
      }

      2 {
        # Close first the reader, then later the writer.
        if {$n==5}  { catch {db2 eval commit} }
        if {$n==10} { catch {db3 eval commit} }
        return 0
      }

      3 {
        # Close first the writer, then later the reader.
        if {$n==5}  { catch {db2 eval commit} }
        if {$n==10} { catch {db3 eval commit} }
        return 0
      }
    }
  }

  foreach {mode busy_handler_mode} { 
    passive 1
    full    1
    full    2
    full    3
  } {

    set ::sync_counter 0

    proc tvfs_callback {method args} {
      set tail [file tail [lindex $args 0]]
      if {$method == "xSync" && $tail == "test.db"} {
        incr ::sync_counter
      }

      if {$method == "xWrite" && $tail=="test.db"} {
        if {$::write_ok < 0} {
          set ::write_ok [expr ![catch {db5 eval { BEGIN IMMEDIATE }}]]
          catch { db5 eval ROLLBACK }
        }
        if {$::read_ok < 0} {
          set ::read_ok [expr ![catch {db5 eval { SELECT * FROM t1 }}]]
        }
      }
    }

    catch { db close }
    forcedelete test.db
    testvfs tvfs
    sqlite3 db test.db -vfs tvfs
    #tvfs filter xSync
    tvfs script tvfs_callback

    do_execsql_test $tn.4.$mode.0 {
      CREATE TABLE t1(a, b);
      CREATE TABLE t2(a, b);
      PRAGMA journal_mode = wal;
      INSERT INTO t1 VALUES(1, 2);
      INSERT INTO t1 VALUES(3, 4);
      INSERT INTO t1 VALUES(5, 6);
    } {wal}

    # Open a reader on the current database snapshot.
    do_test $tn.4.$mode.1 {
      sqlite3 db2 test.db -vfs tvfs
      execsql {
        BEGIN;
          SELECT * FROM t1 UNION ALL SELECT * FROM t2;
      } db2
    } {1 2 3 4 5 6}

    # Open a writer. Write a transaction. Then begin, but do not commit,
    # a second transaction.
    do_test $tn.4.$mode.2 {
      sqlite3 db3 test.db -vfs tvfs
      execsql {
        INSERT INTO t2 VALUES(7, 8);
        BEGIN;
          INSERT INTO t2 VALUES(9, 10);
          SELECT * FROM t1 UNION ALL SELECT * FROM t2;
      } db3
    } {1 2 3 4 5 6 7 8 9 10}

    sqlite3 db5 test.db -vfs tvfs

    # Register a busy-handler with connection [db].
    #
    db busy [list busy_handler $mode $busy_handler_mode]
    set ::sync_counter 0
    set ::busy_handler_counter 0
    set ::read_ok -1
    set ::write_ok -1
    
    do_test $tn.4.$mode.3 {
      checkpoint db $mode main
      set {} {}
    } {}

    if { $mode=="passive" } {
      # EVIDENCE-OF: R-16333-64433 Checkpoint as many frames as possible
      # without waiting for any database readers or writers to finish, then
      # sync the database file if all frames in the log were checkpointed.
      #
      #   "As many frames as possible" means all but the last two transactions
      #   (the two that write to table t2, of which the scond is unfinished).
      #   So copying the db file only we see the t1 change, but not the t2
      #   modifications.
      #
      #   The busy handler is not invoked (see below) and the db reader and
      #   writer are still active - so the checkpointer did not wait for either
      #   readers or writers. As a result the checkpoint was not finished and
      #   so the db file is not synced.
      #
      # EVIDENCE-OF: R-62920-47450 The busy-handler callback is never invoked
      # in the SQLITE_CHECKPOINT_PASSIVE mode.
      #
      #   It's not. Test case "$tn.4.$mode.6".
      #
      do_test $tn.4.$mode.4 {
        forcecopy test.db abc.db
        sqlite3 db4 abc.db
        db4 eval { SELECT * FROM t1 UNION ALL SELECT * FROM t2 }
      } {1 2 3 4 5 6}
      do_test $tn.4.$mode.5 { set ::sync_counter } 0
      do_test $tn.4.$mode.6 { set ::busy_handler_counter } 0
      db4 close
  
      db2 eval COMMIT
      db3 eval COMMIT
  
      # EVIDENCE-OF: R-65499-53765 On the other hand, passive mode might leave
      # the checkpoint unfinished if there are concurrent readers or writers.
      #
      #   The reader and writer have now dropped their locks. And so a 
      #   checkpoint now is able to checkpoint more frames. Showing that the
      #   attempt above was left "unfinished".
      #
      #   Also, because the checkpoint finishes this time, the db is synced.
      #   Which is part of R-16333-64433 above.
      #
      do_test $tn.4.$mode.7 {
        checkpoint db $mode main
        forcecopy test.db abc.db
        sqlite3 db4 abc.db
        db4 eval { SELECT * FROM t1 UNION ALL SELECT * FROM t2 }
      } {1 2 3 4 5 6 7 8 9 10}
      do_test $tn.4.$mode.6 { set ::sync_counter } 1
      do_test $tn.4.$mode.7 { set ::busy_handler_counter } 0
      db4 close
    }

    if { $mode=="full" } {
      if {$busy_handler_mode==2 || $busy_handler_mode==3} {
        # EVIDENCE-OF: R-59171-47567 This mode blocks (it invokes the
        # busy-handler callback) until there is no database writer and all
        # readers are reading from the most recent database snapshot.
        #
        #   Show that both the reader and writer have finished:
        #
        do_test $tn.4.$mode.7 {
          list [catchsql COMMIT db2] [catchsql COMMIT db3]
        } [list                                             \
            {1 {cannot commit - no transaction is active}}  \
            {1 {cannot commit - no transaction is active}}  \
        ]

        # EVIDENCE-OF: R-29177-48281 It then checkpoints all frames in the log
        # file and syncs the database file.
        #
        do_test $tn.4.$mode.8 {
          forcecopy test.db abc.db
          sqlite3 db4 abc.db
          db4 eval { SELECT * FROM t1 UNION ALL SELECT * FROM t2 }
        } {1 2 3 4 5 6 7 8 9 10}
        do_test $tn.4.$mode.9 { set ::sync_counter } 1
        db4 close

        # EVIDENCE-OF: R-51867-44713 This mode blocks new database writers
        # while it is pending, but new database readers are allowed to continue
        # unimpeded.
        do_test $tn.4.$mode.10 {
          list $::write_ok $::read_ok
        } {0 1}

      }
    }

    db2 close
    db3 close
    db5 close
  }

  db close
  tvfs delete
}

#-----------------------------------------------------------------------
# EVIDENCE-OF: R-03996-12088 The M parameter must be a valid checkpoint
# mode:
#
#   Valid checkpoint modes are 0, 1, 2 and 3.
#
sqlite3 db test.db
foreach {tn mode res} {
  0 -1001    {1 {SQLITE_MISUSE - not an error}}
  1 -1       {1 {SQLITE_MISUSE - not an error}}
  2  0       {0 {0 -1 -1}}
  3  1       {0 {0 -1 -1}}
  4  2       {0 {0 -1 -1}}
  5  3       {0 {0 -1 -1}}
  6  4       {1 {SQLITE_MISUSE - not an error}}
  7  114     {1 {SQLITE_MISUSE - not an error}}
  8  1000000 {1 {SQLITE_MISUSE - not an error}}
} {
  do_test 4.$tn {
    list [catch "sqlite3_wal_checkpoint_v2 db $mode" msg] $msg
  } $res
}


finish_test
