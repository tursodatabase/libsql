# 2001 September 15
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for SQLite library.  The
# focus of this script is database locks.
#
# $Id: lock.test,v 1.11 2001/09/23 02:35:53 drh Exp $


set testdir [file dirname $argv0]
source $testdir/tester.tcl

# Create an alternative connection to the database
#
do_test lock-1.0 {
  sqlite db2 ./test.db
} {}
do_test lock-1.1 {
  execsql {SELECT name FROM sqlite_master WHERE type='table' ORDER BY name}
} {}
do_test lock-1.2 {
  execsql {SELECT name FROM sqlite_master WHERE type='table' ORDER BY name} db2
} {}
do_test lock-1.3 {
  execsql {CREATE TABLE t1(a int, b int)}
  execsql {SELECT name FROM sqlite_master WHERE type='table' ORDER BY name}
} {t1}
do_test lock-1.4 {
  set r [catch {execsql {
     SELECT name FROM sqlite_master WHERE type='table' ORDER BY name
  } db2} msg]
  lappend r $msg
} {1 {database schema has changed}}
do_test lock-1.5 {
  set r [catch {execsql {
     SELECT name FROM sqlite_master WHERE type='table' ORDER BY name
  } db2} msg]
  lappend r $msg
} {0 t1}

do_test lock-1.6 {
  execsql {INSERT INTO t1 VALUES(1,2)}
  execsql {SELECT * FROM t1}
} {1 2}
do_test lock-1.7 {
  execsql {SELECT * FROM t1} db2
} {1 2}
do_test lock-1.8 {
  execsql {UPDATE t1 SET a=b, b=a} db2
  execsql {SELECT * FROM t1} db2
} {2 1}
do_test lock-1.9 {
  execsql {SELECT * FROM t1}
} {2 1}

do_test lock-1.10 {
  execsql {BEGIN TRANSACTION}
  execsql {SELECT * FROM t1}
} {2 1}
do_test lock-1.11 {
  set r [catch {execsql {SELECT * FROM t1} db2} msg]
  lappend r $msg
} {1 {database is locked}}
do_test lock-1.12 {
  execsql {ROLLBACK}
  set r [catch {execsql {SELECT * FROM t1} db2} msg]
  lappend r $msg
} {0 {2 1}}

do_test lock-1.13 {
  execsql {CREATE TABLE t2(x int, y int)}
  execsql {INSERT INTO t2 VALUES(8,9)}
  execsql {SELECT * FROM t2}
} {8 9}
do_test lock-1.14 {
  set r [catch {execsql {SELECT * FROM t1} db2} msg]
  lappend r $msg
} {1 {database schema has changed}}
do_test lock-1.15 {
  set r [catch {execsql {SELECT * FROM t2} db2} msg]
  lappend r $msg
} {0 {8 9}}

do_test lock-1.16 {
  db eval {SELECT * FROM t1} qv {
    set x [db eval {SELECT * FROM t1}]
  }
  set x
} {2 1}
do_test lock-1.17 {
  db eval {SELECT * FROM t1} qv {
    set x [db eval {SELECT * FROM t2}]
  }
  set x
} {8 9}

# You cannot UPDATE a table from within the callback of a SELECT
# on that same table because the SELECT has the table locked.
#
do_test lock-1.18 {
  db eval {SELECT * FROM t1} qv {
    set r [catch {db eval {UPDATE t1 SET a=b, b=a}} msg]
    lappend r $msg
  }
  set r
} {1 {database table is locked}}

# But you can UPDATE a different table from the one that is used in
# the SELECT.
#
do_test lock-1.19 {
  db eval {SELECT * FROM t1} qv {
    set r [catch {db eval {UPDATE t2 SET x=y, y=x}} msg]
    lappend r $msg
  }
  set r
} {0 {}}
do_test lock-1.20 {
  execsql {SELECT * FROM t2}
} {9 8}

# It is possible to do a SELECT of the same table within the
# callback of another SELECT on that same table because two
# or more read-only cursors can be open at once.
#
do_test lock-1.21 {
  db eval {SELECT * FROM t1} qv {
    set r [catch {db eval {SELECT a FROM t1}} msg]
    lappend r $msg
  }
  set r
} {0 2}

# Under UNIX you can do two SELECTs at once with different database
# connections, because UNIX supports reader/writer locks.  Under windows,
# this is not possible.
#
if {$::tcl_platform(platform)=="unix"} {
  do_test lock-1.22 {
    db eval {SELECT * FROM t1} qv {
      set r [catch {db2 eval {SELECT a FROM t1}} msg]
      lappend r $msg
    }
    set r
  } {0 2}
}


do_test lock-999.1 {
  rename db2 {}
} {}

finish_test
