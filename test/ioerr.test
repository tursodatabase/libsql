# 2001 October 12
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for SQLite library.  The
# focus of this file is testing for correct handling of I/O errors
# such as writes failing because the disk is full.
# 
# The tests in this file use special facilities that are only
# available in the SQLite test fixture.
#
# $Id: ioerr.test,v 1.9 2005/01/11 10:25:07 danielk1977 Exp $

set testdir [file dirname $argv0]
source $testdir/tester.tcl

set ::AV [execsql {pragma auto_vacuum}]

set ::go 1
for {set n 1} {$go} {incr n} {

  # If SQLITE_DEFAULT_AUTOVACUUM is set to true, then a simulated IO error
  # on the 8th IO operation in the SQL script below doesn't report an error.
  #
  # This is because the 8th IO call attempts to read page 2 of the database
  # file when the file on disk is only 1 page. The pager layer detects that
  # this has happened and suppresses the error returned by the OS layer.
  #
  if {$::AV} {
    if {$n==8} continue
  } 

  do_test ioerr-1.$n.1 {
    set ::sqlite_io_error_pending 0
    db close
    catch {file delete -force test.db}
    catch {file delete -force test.db-journal}
    sqlite3 db test.db
    execsql {SELECT * FROM sqlite_master}
  } {}
  do_test ioerr-1.$n.2 [subst {
    set ::sqlite_io_error_pending $n
  }] $n
  do_test ioerr-1.$n.3 {
    set r [catch {db eval {
      CREATE TABLE t1(a,b,c);
      SELECT * FROM sqlite_master;
      BEGIN TRANSACTION;
      INSERT INTO t1 VALUES(1,2,3);
      INSERT INTO t1 VALUES(4,5,6);
      ROLLBACK;
      SELECT * FROM t1;
      BEGIN TRANSACTION;
      INSERT INTO t1 VALUES(1,2,3);
      INSERT INTO t1 VALUES(4,5,6);
      COMMIT;
      SELECT * FROM t1;
      DELETE FROM t1 WHERE a<100;
    }} msg]
    # if {$r} {puts $msg}
    set ::go [expr {$::sqlite_io_error_pending<=0}]
    expr {$::sqlite_io_error_pending>0 || $r!=0}
  } {1}
}
set ::sqlite_io_error_pending 0

proc cksum {{db db}} {
  set txt [$db eval {
      SELECT name, type, sql FROM sqlite_master order by name
  }]\n
  foreach tbl [$db eval {
      SELECT name FROM sqlite_master WHERE type='table' order by name
  }] {
    append txt [$db eval "SELECT * FROM $tbl"]\n
  }
  foreach prag {default_synchronous default_cache_size} {
    append txt $prag-[$db eval "PRAGMA $prag"]\n
  }
  set cksum [string length $txt]-[md5 $txt]
  # puts $cksum-[file size test.db]
  return $cksum
}

set ::go 1
for {set n 1} {$go} {incr n} {
  if {$n==24} breakpoint
  do_test ioerr-2.$n.1 {
    set ::sqlite_io_error_pending 0
    db close
    catch {file delete -force test.db}
    catch {file delete -force test.db-journal}
    sqlite3 db test.db
    execsql {
      BEGIN;
      CREATE TABLE t1(a, b, c);
      INSERT INTO t1 VALUES(1, randstr(5,50), randstr(5,50));
      INSERT INTO t1 SELECT a+2, b||'-'||rowid, c||'-'||rowid FROM t1;
      INSERT INTO t1 SELECT a+4, b||'-'||rowid, c||'-'||rowid FROM t1;
      INSERT INTO t1 SELECT a+8, b||'-'||rowid, c||'-'||rowid FROM t1;
      INSERT INTO t1 SELECT a+16, b||'-'||rowid, c||'-'||rowid FROM t1;
      INSERT INTO t1 SELECT a+32, b||'-'||rowid, c||'-'||rowid FROM t1;
      INSERT INTO t1 SELECT a+64, b||'-'||rowid, c||'-'||rowid FROM t1;
      INSERT INTO t1 SELECT a+128, b||'-'||rowid, c||'-'||rowid FROM t1;
      INSERT INTO t1 VALUES(1, randstr(600,600), randstr(600,600));
      CREATE TABLE t2 AS SELECT * FROM t1;
      CREATE TABLE t3 AS SELECT * FROM t1;
      COMMIT;
      DROP TABLE t2;
    }
    set ::cksum [cksum]
    execsql {
      SELECT name FROM sqlite_master WHERE type='table'
    }
  } {t1 t3}
  do_test ioerr-2.$n.2 [subst {
    set ::sqlite_io_error_pending $n
  }] $n
  do_test ioerr-2.$n.3 {
    set r [catch {db eval {
      VACUUM;
    }} msg]
    set ::go [expr {$::sqlite_io_error_pending<=0}]
    expr {$::sqlite_io_error_pending>0 || $r!=0}
    set ::sqlite_io_error_pending 0
    db close
    sqlite3 db test.db
    cksum
  } $cksum
}
set ::sqlite_io_error_pending 0

set ::go 1
for {set n 1} {$go} {incr n} {
  do_test ioerr-3.$n.1 {
    set ::sqlite_io_error_pending 0
    db close
    catch {file delete -force test.db}
    catch {file delete -force test.db-journal}
    sqlite3 db test.db
    execsql {
      PRAGMA cache_size = 10;
      BEGIN;
      CREATE TABLE abc(a);
      INSERT INTO abc VALUES(randstr(1500,1500)); -- Page 4 is overflow
    }
    for {set i 0} {$i<150} {incr i} {
      execsql {
        INSERT INTO abc VALUES(randstr(100,100)); 
      }
    }
    execsql COMMIT
  } {}
  do_test ioerr-3.$n.2 [subst {
    set ::sqlite_io_error_pending $n
  }] $n
  do_test ioerr-3.$n.3 {
    set r [catch {db eval {
      CREATE TABLE abc2(a);
      BEGIN;
      DELETE FROM abc WHERE length(a)>100;
      UPDATE abc SET a = randstr(90,90);
      COMMIT;
      CREATE TABLE abc3(a);
    }} msg]
    set ::go [expr {$::sqlite_io_error_pending<=0}]
    expr {$::sqlite_io_error_pending>0 || $r!=0}
  } {1}
}
set ::sqlite_io_error_pending 0

finish_test
