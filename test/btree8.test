# 2004 Jun 4	
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for SQLite library.  The
# focus of this script is btree database backend. Specifically,
# this file tests that existing cursors are correctly repositioned 
# when entries are inserted into or deleted from btrees.
#
# $Id: btree8.test,v 1.4 2004/11/17 10:22:04 danielk1977 Exp $

set testdir [file dirname $argv0]
source $testdir/tester.tcl

# Test organization:
#
# btree-8.1.*: Test cursor persistence when inserting records into tables.
# btree-8.2.*: Test cursor persistence when deleting records from tables.
# btree-8.3.*: Test cursor persistence when inserting records into indices.
# btree-8.4.*: Test cursor persistence when deleting records from indices.
#

# Transform the number $num into a string of length $len by repeating the
# string representation of the number as many times as necessary. Repeats
# are seperated by a '.' character. Eg:
#
# [num_to_string 456 10] -> "456.456.45"
#
proc num_to_string {num len} {
  set num [format %.4d $num]
  return [string range [string repeat "$num." $len] 0 [expr $len-1]]
}

# Proc lshuffle takes a list as an argument and returns a copy of that
# list in randomized order. It uses the K-combinator for speed.
#
proc K {x y} {set x}
proc lshuffle { list } {
    set n [llength $list]
    while {$n>0} {
        set j [expr {int(rand()*$n)}]
        lappend slist [lindex $list $j]
        set list [lreplace [K $list [set list {}]] $j $j]
        incr n -1
    }
    return $slist
}

# Proc lremove takes two arguments, a list (the first argument) and a key
# (the second argument). A copy of the list is returned with all elements
# equal to $key removed.
#
proc lremove {list key} {
  while { [set i [lsearch $list $key]] != -1 } {
    set list [concat \
        [lrange $list 0 [expr $i-1]] \
        [lrange $list [expr $i+1] end]
    ]
  }
  return $list
}


# Use the SQL interface to create a couple of btree tables, one using
# the flags for an SQL table, the other an SQL index.
# 
do_test btree8-0.0 {
  execsql {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b);
    CREATE INDEX i1 ON t1(b);
  }
} {}
set tnum [execsql {SELECT rootpage FROM sqlite_master where type = 'table'}]
set inum [execsql {SELECT rootpage FROM sqlite_master where type = 'index'}]
db close

#-------------------------------------------------------------------------
# Tests btree8-1.* insert a handful of records (~10) into the type of 
# b-tree created for an SQL table. The records have integer keys in the 
# range 1..5000. A cursor is left pointing to each of these records. 
# Then, a record is inserted for each key value between 1 and 5000,
# including the values for which a record already exists (overwriting
# the original). After each record is inserted, the existing cursors
# are checked to ensure they still point at the same key-value.
#

# Open the database at the btree level and begin a transaction
do_test btree8-1.0 {
  set ::bt [btree_open test.db 100 0]
  expr 0
} {0}

do_test btree8-1.1 {
  btree_begin_transaction $::bt
  expr 0
} {0}

# For each element in the list $keys, insert an entry into the SQL table
# with the corresponding key value. Check that the cursor used to insert
# the key is left pointing to it after the insert. Then save this cursor
# in the list $csr_list.
#
set keys [list 3178 4886 719 1690 443 4113 1618 310 1320 2028]
set csr_list [list]
set testnum 2
foreach key $keys {
  do_test btree-8-1.$testnum {
    set csr [btree_cursor $::bt $::tnum 1]
    btree_insert $csr $key [string repeat a 10]
    lappend csr_list $csr
    btree_key $csr
  } $key
  incr testnum 
}
btree_commit $::bt

# Now write more entries to the table (and overwriting the ones that exist).
# After each write, check that the cursors created above still point to the
# same entries.
btree_begin_transaction $::bt
set ::write_csr [btree_cursor $::bt $::tnum 1]
set first_entry $testnum
for {set i $testnum} {$i < 5000 && $nErr==0 } {incr i} {
  set datalen [expr int(rand()*20.0)]

  do_test btree8-1.$i.1 {
    btree_insert $::write_csr $i [string repeat x $datalen]
  } {}

  set testnum 1
  foreach csr $csr_list key $keys {
    incr testnum
    do_test btree8-1.$i.$testnum {
      btree_key $::csr
    } $key
  }
}

#-------------------------------------------------------------------------
# Tests btree8-2.* loop through the tree created by tests btree8-1.*,
# deleting records in sequential order. After each record is deleted,
# each of the open cursors is checked to ensure that it still points
# to the same key-value or, if that key value has been deleted, returns
# 0 as the integer key value.
#

# Now delete entries from the table.
btree_first $::write_csr
for {set i $first_entry} {$i < 5000 && $nErr==0 } {incr i} {

  do_test btree8-2.$i.1 {
    btree_key $::write_csr
  } $i
  do_test btree8-2.$i.2 {
    btree_delete $::write_csr
    btree_next $::write_csr
    expr 0
  } {0}
  set testnum 2
  foreach csr $csr_list key $keys {
    incr testnum
    if {$key <= $i } {
      set key 0
    }
    do_test btree8-2.$i.$testnum {
      btree_key $::csr
    } $key
  }
}

# Close all existing cursors and conclude the open transaction.
btree_close_cursor $::write_csr
btree_commit $::bt
if {$::nErr>0} { puts $::csr_list ; exit }
foreach csr $csr_list {
  btree_close_cursor $csr
}
set csr_list [list]

#-------------------------------------------------------------------------
# Tests btree8-3.* are analogous to btree8-1.*, but use the type of btree
# created for an SQL index, not an SQL table. Instead of integers, key 
# values are strings 20 bytes long created by transforming integers
# into string using the [num_to_string] proc (see above).
#

foreach key $keys {
  lappend skeys [num_to_string $key 20]
}

# For each element in the list $skeys, insert an entry into the SQL index
# with the corresponding key value. Check that the cursor used to insert
# the key is left pointing to it after the insert. Then save this cursor
# in the list $csr_list.
#
btree_begin_transaction $::bt
set testnum 0
foreach key $skeys {
  incr testnum 
  do_test btree-8-3.$testnum {
    set csr [btree_cursor $::bt $::inum 1]
    btree_insert $csr $key ""
    lappend csr_list $csr
    btree_key $csr
  } $key
}
btree_commit $::bt

# Now write more entries to the index (and overwrite the ones that exist).
# After each write, check that the cursors created above still point to the
# same entries.
btree_begin_transaction $::bt
set ::write_csr [btree_cursor $::bt $::inum 1]
set first_entry $testnum
for {set i $testnum} {$i < 5000 && $nErr==0 } {incr i} {
  set skey [num_to_string $i 20]

  do_test btree-8-3.$i.1 {
    btree_insert $::write_csr $skey ""
  } {}

  set testnum 1
  foreach csr $csr_list key $skeys {
    incr testnum
    do_test btree-8-3.$i.$testnum {
      btree_key $::csr
    } $key
  }
}
btree_commit $::bt
btree_begin_transaction $::bt

#-------------------------------------------------------------------------
# Tests btree8-4.* are analogous to btree8-2.*, but use the type of btree
# created for an SQL index, not an SQL table. Instead of integers, key 
# values are strings 20 bytes long created by transforming integers
# into string using the [num_to_string] proc (see above). Also, keys
# are deleted in random order, calculated by the [lshuffle] proc (see above).
#

# Now delete entries from the index. Do this in a random order, to try to
# ensure that internal and external nodes are deleted.
for {set i $first_entry} {$i < 5000} {incr i} {
  lappend delete_order $i
}
set delete_order [lshuffle $delete_order]

btree_first $::write_csr
foreach i $delete_order { 
  do_test btree8-4.$i.1 {
    btree_move_to $::write_csr [num_to_string $i 20]
    btree_key $::write_csr
  } [num_to_string $i 20]
  do_test btree8-4.$i.2 {
    btree_delete $::write_csr
  } {}
  set delete_order [lremove $delete_order $i]
  set testnum 2
  foreach csr $csr_list key $keys {
    incr testnum
    if { [lsearch $delete_order $key]==-1 } {
      set skey ""
    } else {
      set skey [num_to_string $key 20]
    }
    do_test btree8-4.$i.$testnum {
      btree_key $::csr
    } $skey
  }
}

btree_close_cursor $::write_csr
btree_commit $::bt
if {$::nErr>0} { puts $::csr_list }
foreach csr $csr_list {
  btree_close_cursor $csr
}
set csr_list [list]

#------------------------------------------------------------------------
# Tests btree8.5.* also test the types of trees used for SQL indices. 
# This time, 300 entries of 150 bytes each are inserted into the btree (this
# produces a tree of height 3 - root page is the grandparent of the leaves).
# A cursor points at each entry. We check that all cursors retain there
# validity when:
#
# * Each entry is deleted (test cases btree-8.5.1.*)
# * An entry is inserted just after/before each existing key (test 
#   cases btree-8.5.2.*).
#

# Open a cursor on each entry in the tree in B-tree $bt, root-page $tnum.
# Return a list of the cursors.
#
proc open_cursors {bt tnum} {
  set c [btree_cursor $bt $tnum 0]
  set csr_list [list]
  for {btree_first $c} {![btree_eof $c]} {btree_next $c} {
    set c2 [btree_cursor $bt $tnum 0]
    btree_move_to $c2 [btree_key $c]
    lappend csr_list $c2
  }
  btree_close_cursor $c
  return $csr_list
}

# Close all cursors in the list $csr_list.
#
proc close_cursors {csr_list} { 
  foreach c $csr_list {
    btree_close_cursor $c
  }
}

# Check that the key for each cursor in csr_list matches the corresponding
# entry in key_list. If not, raise an exception.
#
proc check_cursors {key_list csr_list} {
  foreach k $key_list c $csr_list {
    if {[string compare $k [btree_key $c]]} {
      error "Csr key '[btree_key $c]' - should be '$k'"
    }
  }
}

# Set up the table used for the btree-8.5.* tests
do_test btree-8.5.0 {
  btree_begin_transaction $::bt
  set c [btree_cursor $::bt $::inum 1]
  for {set i 2} {$i<=600} {incr i 2} { 
    set key [num_to_string $i 150]
    lappend key_list $key
    btree_insert $c $key ""
  }
  btree_close_cursor $c
  btree_commit $::bt
} {}

# Test cases btree-8.5.1.* - Check that cursors survive DELETE operations.
set testnum 0
foreach key [lrange $::key_list 0 0] {
  incr testnum

  btree_begin_transaction $::bt

  # Open the 300 cursors.
  do_test btree-8.5.1.$testnum.1 {
    set ::csr_list [open_cursors $::bt $::inum]
    llength $::csr_list
  } {300}

   # Delete an entry.
   do_test btree-8.5.1.$testnum.2 {
     set c [btree_cursor $::bt $::inum 1]
     btree_move_to $c $::key
     btree_delete $c
     btree_close_cursor $c
   } {}
 
   # Check that all 300 cursors are Ok.
   do_test btree-8.5.1.$testnum.3 {
     catch {
       set e [lsearch $::key_list $::key]
       check_cursors [lreplace $::key_list $e $e ""] $::csr_list
     } msg
     set msg
   } {}

  close_cursors $::csr_list
  btree_rollback $::bt
}

# Test cases btree-8.5.2.* - Check that cursors survive INSERT operations.
set testnum 0
foreach key $::key_list {
  incr testnum

  btree_begin_transaction $::bt

  # Open the 300 cursors.
  do_test btree-8.5.2.$testnum.1 {
    set ::csr_list [open_cursors $::bt $::inum]
    llength $::csr_list
  } {300}

  # Insert new entries, one before the key, and one after.
  do_test btree-8.5.2.$testnum.2 {
    set c [btree_cursor $::bt $::inum 1]
    btree_insert $c "$::key$::key" ""
    btree_insert $c [string range $::key 0 end-1] ""
    btree_close_cursor $c
  } {}

  # Check that all 300 cursors are Ok.
  do_test btree-8.5.2.$testnum.3 {
    catch {
      check_cursors $::key_list $::csr_list
    } msg
    set msg
  } {}

  close_cursors $::csr_list
  btree_rollback $::bt
}

finish_test

